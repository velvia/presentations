<!DOCTYPE html>
<html>
  <head>
    <title>2019 SBTB Rust Scala</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

     /* Two-column layout */
      .left-column {
        /*color: #777;*/
        width: 44%;
        /*height: 92%;*/
        float: left;
      }
/*        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
*/
      .right-column {
        width: 44%;
        float: right;
        /*padding-top: 1em;*/
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Rust and Scala, Sitting in a Tree

## Scale by the Bay - Nov 2019

.red[Evan Chan]

---

# About me

* http://github.com/filodb/FiloDB
* http://github.com/velvia
* [@evanfchan](https://twitter.com/Evanfchan)
* [IG: @platypus.arts](http://instagram.com/platypus.arts)

---

# Hello Rust

```rust
  fn main() {
    println!("Hello World!");
  }
```

---

# How I Got Into Rust

* FiloDB - in memory TSDB
  * 100 billion compressed data points on single node
  * Almost 100% Scala
* Storing data on heap was not feasible
  * Object graphs had >50% overhead
  * nasty and unpredictable GC issues

???
Thought I'd talk about something a bit more universal than in memory DBs.. :)

--

* .red[*but managing offheap memory manually is hard!*]
* Byte-level high performance data manipulation is nasty in JVM and very error prone

---

# How I Got Into Rust (II)

2018 SBTB: Brian Cantrill
(https://www.youtube.com/watch?v=2wZ1pCpJUIM)

* Rust: "Pick 3 - performance, safety, and high-level abstractions"
* Structs for efficient + safe low level data processing
* Provably correct native memory management
* Super high performance ceiling with SIMD
* Takes great advantage of architectural trends
  * CPUs not getting faster
  * Safe concurrency, GPU, SIMD, efficient memory use, XPoint, etc.

<!-- ---

# Rust and Values

* Pick 3 - performance, safety, and high-level abstractions
* "Itâ€™s basically C++ with newer syntax that guides programmer towards safety still allowing low-level control, how does it do it?" .red[*]

What are Scala's values?

 -->
---

class: center, middle

# Memory Model and Memory Safety

---

# Scala Memory Model

.left-column[
  ### Stack
  * Primitives
  * References to objects
]
.right-column[
  ### Heap
  * Objects - everything non-primitive
]

---

# Scala Memory Model - GC

<div class="mermaid">
  graph LR
  OBJ1 --> OBJ2
  OBJ2 --> OBJ3
  OBJ2 --> Array4
  Array4 --> Elem0
  Array4 --> Elem1
</div>

JVM has the best garbage collection tech, hands down.
Makes many things super convenient.
Really good fit for short- and medium- term data.
Solves reliable sharing of data.
Does have a cost.

---

# Rust Memory Model

.left-column[
  ### Stack
  * Primitives
  * Structs (fixed size)
  * Fixed size arrays
  * Pointers/references
]
.right-column[
  ### Heap
  * Vecs (lists, arrays)
  * Strings
  * Dynamic-sized objects

  Rust has no GC - how does it manage heap memory?
]

---

# Rust Memory Model: Safety

Simple principle:

### Allow mutation only if someone has *unique* access to data.

Rust's compiler tries to prove who has unique access.

---

# Rust: Ownership

```rust
// invalid
let x = String::from("hello");
let y = x;
println!("{}", x);
```

* Heap objects deallocated when variables go out of scope
* x is initial owner
* ownership transferred to y - for strings, data is not copied
* last line does not compile: as x is no longer owner
* single ownership guarantees no reference possible after memory freed
* Scoping and ownership ensure objects are valid when referenced

---

# Rust: Borrowing

```rust
let x = String::from("hello");
let y = &x ;
println!("{}", x);
println!("{}", y);
```

* Unlimited number of immutable references / readers
* Only one mutable reference `&mut T` allowed
  * and only those with unique ownership can create a mutable ref
* References cannot outlive the scope of original variable

---

class: center, middle

Conor McBride: "sometimes it's easier to search for good programs in the space of well typed programs rather than in the space of ASCII turds"

---

# Using Type System for Safety

Traits in Rust to prevent memory and concurrency safety issues at compile time:

* `T: Move` - lists/arrays; ownership transfers to new owner
* `T: Copy` - primitives and structs are copied, independent mutation possible
* `T: Send` - one thread at a time has exclusive ownership/borrowing
* `T: Sync` - multi-threaded ownership/sharing

---

class: center, middle

# Safety by Default

---

# Immutability

### Scala: Surface-level immutability, opt-in

```scala
  val map = new collection.mutable.HashMap[String, String]()
  map += "mykey" -> "myvalue"
```

* `val` just means reference is immutable, but object itself is mutable
* Programmer has to opt-in to immutability by choosing immutable data structures

---

# Immutability

### Rust: Immutable by default, Deep Immutability

```rust
use std::collections::HashMap;
fn test() {
    let map = HashMap::new();
    map.insert("key1", "value1");
}
```

The above does not compile, since map is declared by default as immutable and we want to mutate the map.
Note that all APIs have strong notions of mutability baked in.

```rust
error[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable
  --> src/lib.rs:16:5
   |
15 |     let map = HashMap::new();
   |         --- help: consider changing this to be mutable: `mut map`
16 |     map.insert("key1", "value1");
   |     ^^^ cannot borrow as mutable
```

???
Rust does not allow mutation by default.  One has to opt-in to mutation by declaring `let mut`
BTW notice that types are not needed when declaring HashMap, Rust has more advanced type derivation...

---

# Immutability: Objects vs References

```rust
use std::collections::HashMap;
fn test() {
    let mut map = HashMap::new();
    map.insert("key1", "value1");
    let immut_ref = &map ;
    immut_ref.insert("key2", "value2");
}
```

You can have an immutable reference to a mutable object, so that those given immutable references can only read and not mutate.  Above, we can insert into a mutable map, but mutating using an immutable reference results in a compilation error.

```rust
error[E0596]: cannot borrow `*immut_ref` as mutable, as it is behind a `&` reference
  --> src/lib.rs:18:5
   |
17 |     let immut_ref = &map ;
   |                     ---- help: consider changing this to be a mutable reference: `&mut map`
18 |     immut_ref.insert("key2", "value2");
   |     ^^^^^^^^^ `immut_ref` is a `&` reference, so the data it refers to cannot be borrowed as mutable
```

Notice that `rustc` gives you a help in the error message as to how it can be solved.

---

# Thread Safety

### Scala Actor Example

You think, OK an Actor is single-threaded right?  So let me do this:

```scala
class MyActor extends Actor {
  val map = new collections.mutable.HashMap[String, String]
  def receive = {
    case Mutate(k, v) =>
      someFuture.map {
        // Uh oh, this is a diff thread, but easy to forget!
        map += (k, v)
      }
  }
}
```

Common mistake - use a non-thread-safe data structure mutably in another thread

---

# Thread Safety - Rust

Rust prevents the following problems via compiler errors:
* Sharing a reference with another thread could lead to invalid references if the original value is freed (lifetime checks)
* Using a mutable reference in another thread - unless the original data is thread safe (implements `Sync`)

```rust
    let mut map = HashMap::new();
    map.insert("key1", "value1");
    let shared_ref = Arc::new(map);
    let h = {
        let shared1 = Arc::clone(&shared_ref);
        thread::spawn(move || shared1.insert("key1", "val1").is_some())
    };
```

```rust
error[E0596]: cannot borrow data in an `Arc` as mutable
  --> src/lib.rs:23:31
   |
23 |         thread::spawn(move || shared1.insert("key1", "val1").is_some())
   |                               ^^^^^^^ cannot borrow as mutable
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::sync::Arc<std::collections::HashMap<&str, &str>>`
```

---

# Null Safety

### Scala

This is possible: `Some(null)`

### Rust

* No null value at all
* In fact, references to random memory addresses can't be created (*)
* Use of `Option` type is very cheap and used in virtually all APIs where absence of value is possible

???
Unless you use unsafe stuff in Rust

---

# Safe Numeric Processing

* Rust does not coerce `Ints` to `Longs` and so forth automatically
* Explicit signed and unsigned types, operators like `>>` appropriate to sign-ness
  * Scala: you have to pick right operator (`>>` vs `>>>`) depending on if you want signed or unsigned shift.
  * Opt-in correctness  :(
  * Rust: `u16 >>` is unsigned shift, `i16 >>` is a signed shift.  Type and compiler enforced!
* Different methods for handling overflows
  * `checked_add`
  * `overflowing_add`
  * `saturating_add`
* 128-bit primitive type is kinda cool

---

class: center, middle

# Performance AND Abstrations

---

# Structs and Performance

Really big deal for data processing and databases.

Example1: Scala object graph, from FiloDB, bunch of case classes

```scala
final case class ChunkQueryInfo(info: ChunkSetInfo,
                                tsReader: LongDataReader, valueReader: VectorDataReader)
final case class ChunkSetInfo(id: Long, startTime: Long, endTime: Long,
                              numRows: Int, chunks: Seq[ChunkPointer])
val chunksToQuery: Seq[ChunkQueryInfo]
```

Memory Usage:
* `ChunkQueryInfo` - 8/16 byte header + 3 references
* LondDataReader and VectorDataReaders - 8/16 byte headers + fields
* `ChunkSetInfo` - 8/16 byte header + 28 bytes fields + reference
* `Seq[ChunkPointer]` - 8/16 bytes each for Seq + Array headers, + `java.lang.Long` for each element (boxing)

For chunks length of 2, each `ChunkQueryInfo` has an object overhead of up to 128 bytes, around same size as size of fields themselves!

---

# Structs in Rust

```rust
struct ChunkQueryInfo {
  info: ChunkSetInfo,
  ts_reader: LongDataReader,
  valueReader: VectorDataReader
}
struct ChunkSetInfo {
  id: u64,
  start_time: u64,
  end_time: u64,
  num_rows: u32,
  chunks: Vec<&Chunk>
}
```

* Inlined structs allow Rust to save memory:
  * No object overhead, Vec has struct of 24 bytes (x86_64) vs 8 for a reference
  * 112 byte advantage per `ChunkQueryInfo`
* Rust performance advantage: returning structs on stack vs object allocation
  * Performance + safety: fearlessly use Option everywhere
* In Scala, we ended up moving above graph to offheap, which made debugging and readability much much harder

???
I've found myself, SO many times, choosing a hack in FiloDB just to avoid object allocations on returns.  This is a serious JVM deficiency for high-performance code.

---

# Scala: Functional Transform Example

```scala
object CountEvens {
  def apply(numbers: Seq[Int]): Int =
    numbers.filter(n => (n % 2) == 0).length
}
```

--

```
public int apply(scala.collection.Seq<java.lang.Object>);
    descriptor: (Lscala/collection/Seq;)I
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=2, args_size=2
         0: aload_1
         1: new           #16                 // class CountEvens$$anonfun$apply$1
         4: dup
         5: invokespecial #17                 // Method CountEvens$$anonfun$apply$1."<init>":()V
         8: invokeinterface #23,  2           // InterfaceMethod scala/collection/Seq.filter:(Lscala/Function1;)Ljava/lang/Object;
```

* Object allocation: the inner closure is a Function1, must be initialized

---

# Scala: Functional Transform Example (II)

```
 public final java.lang.Object apply(java.lang.Object);
    descriptor: (Ljava/lang/Object;)Ljava/lang/Object;
    flags: ACC_PUBLIC, ACC_FINAL, ACC_BRIDGE, ACC_SYNTHETIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: invokestatic  #31                 // Method scala/runtime/BoxesRunTime.unboxToInt:(Ljava/lang/Object;)I
         5: invokevirtual #33                 // Method apply:(I)Z
         8: invokestatic  #37                 // Method scala/runtime/BoxesRunTime.boxToBoolean:(Z)Ljava/lang/Boolean;
        11: areturn
```

* Scala closures are boxed.  Thus, each Int needs to be boxed, passed to the apply() method of the closure as `java.lang.Object`, then unboxed
* The boolean result of the `filter` method needs to be boxed to `java.lang.Boolean`
* Due to the virtual interface method, and the many implementations of function1, the JVM probably cannot inline this method

---

# Rust: Performance AND Abstractions

Rust OTOH is able to fully optimize nice functional transforms with inlining and no boxing.

```rust
pub fn count_evens(nums: Vec<i32>) -> usize {
    nums.iter().filter(|&x| x % 2 == 0).count()
}
```

The transform above is compiled into a very tight register-only loop: 100% inlined, no allocations, no method calls

```
     mov     rdi, qword, ptr, [rdi]
     mov     rcx, qword, ptr, [rax, +, 16]
     test    rcx, rcx
     je      LBB37_1
     lea     rdx, [4*rcx, -, 4]
     shr     rdx, 2
     inc     rdx
     cmp     rdx, 4
     jae     LBB37_4
     xor     ebx, ebx
     mov     rdx, rdi
     jmp     LBB37_12
LBB37_1:
```

---

# Use case: Rust in Data Processing

* Safe low-level manipulation (structs, exact layout, memory safety)
* C-like performance with no-cost abstractions
* Safety: no numeric coercion; control over boundary conditions
* Exact control of memory allocation for large datasets
* Use high-level constructs without GC pauses
* Easy SIMD, GPU access, easy integration with native libraries
  * Tensorflow, BLAS, RocksDB, etc. etc.
* Super fast UTF8 processing performance for NLP, regex etc.

---

# Rust Data Processing Apps

* [Timely Dataflow](https://github.com/TimelyDataflow/timely-dataflow) - distributed data-parallel compute engine
* [DataFusion](https://arrow.apache.org/blog/2019/02/04/datafusion-donation/) - Apache Arrow's query engine
* [Weld](https://github.com/weld-project/weld) - Stanford's hi-perf runtime for analytics

* [MinSQL](https://github.com/minio/minsql/blob/master/README.md)
* [Sled](https://github.com/spacejam/sled) - lock-free database engine
* [Ripgrep](https://github.com/BurntSushi/ripgrep) - insanely fast grep utility

* [Are we learning yet?](http://www.arewelearningyet.com) - list of ML Rust crates

---

# Concurrency

.left-column[
  ### Scala
  * Library-based, built on JVM threads
  * Futures (built-in)
  * Huge ecosystem: Akka, Monix, etc. etc.
  * Safety is opt-in
]
.right-column[
  ### Rust
  * Built-in async/await, Future
  * Built-in primitives (thread, mutex, RwLock, Arc, ...)
  * Safety enforced through lifetimes and traits (Send, Sync)
  * Library-based: Actix (actors), Tokio, etc.
  * Just getting started
]

---

# Concurrency: Options

Choose an option to satisfy the compiler:
* Safe threaded access via locking: `RwLock`, `Mutex`, `Arc`
* Use multi-thread safe data structures
* Use channels to communicate with a single thread
* Third party libraries:
  * https://tokio.rs
  * https://github.com/actix/actix

Theme: rustc prevents mistakes, and forces you to pick explicit options.  Also provides non-thread-safe options that are higher-performance, and prevents sharing of those across threads.

---

# Async-Await example

Async code that looks like synchronous code:
(This used to be called CSP in Scala)

```rust
async fn handle_get_counters(
    &self,
    p: &mut P::Deserializer,
) -> Result<ProtocolEncodedFinal<P>, Error> {
    let args = {/* snip: some code using `?` */};
    let res = self.service.get_counters(args).await?;
    let enc = write_message(p, "getCounters", MessageType::Reply, |p| res.write(p))?;
    Ok(enc)
}
```

The `await` after get_counters causes that thread to be suspended, other tasks can then be multiplexed.

(from https://docs.rs/dtolnay/0.0.3/dtolnay/macro._01__await_a_minute.html)

---

# Aside: Asynchronous stack traces in Rust

```rust
thread 'async-task-driver' panicked at 'nested async panic!', src/main.rs:42:5
stack backtrace:
...
   8: async_stack_traces::blow_up::{{closure}}
             at src/main.rs:42
...
  15: async_stack_traces::bar::{{closure}}
             at src/main.rs:37
...
  22: async_stack_traces::foo::{{closure}}
             at src/main.rs:32
...
```

---

# Rust - a Data-Oriented Language

.left-column[
  ### Scala/Java
  * Classes and objects
  * Inheritance
  * Traits as .class files
]
.right-column[
  ### Rust
  * Structs with methods
  * Composition
  * No inheritance
  * Prefer static dispatch when possible
]

---

# Macros

* Standard language feature
* Used everywhere: `println!`, `vec!`, `dbg!`, etc. etc.
* AST-based, similar to Scala macros

New syntax (-ish):
```rust
let map = hashmap!{
    "a" => 1,
    "b" => 2,
};
```

Automatic method/trait derivation:
```rust
#[derive(Serialize, Deserialize)]
struct S {
    #[serde(rename = "a")]
    f: i32,
}
```

(Examples from https://words.steveklabnik.com/an-overview-of-macros-in-rust)

---

# Lessons Learned

* Getting past borrow checker and compiler errors is hard at first.
  * Discord, Rust community everywhere is super helpful
* Hard to get used to language without REPL
* Cargo is fairly awesome build tool.  Sorry, way ahead of SBT.
* JVM/Scala is probably more productive for many use cases. But where Rust is good, it's really good

* Learning Rust has improved my programming everywhere; especially about what it means to be safe.
* Rust works because safety is *universal* and *pervasive*, and the community has made it a priority
  * Partial safety is not real safety
  * Rust forces safety to be IN YOUR FACE ALL THE TIME.
* Being welcoming and inclusive has to be a foundational value of a community, hard to add it after the fact

???
In your face  - maybe that's the way it should be

---

# Rust vs Scala, or Rust + Scala?

.left-column[
  ### Rust Standalone
  * Complete, standalone Rust app
  * Good for trying out in microservice architecture
]
.right-column[
  ### Rust + Scala
  * Use Scala for what it's good at: coordination, networking, distributed systems
  * Embed some Rust for high-performance data processing / concurrency with no bugs
  * Use Rust as a .so / .dylib within JVM
]

---

# Rust + Scala

* [JnrFFI](https://github.com/jnr/jnr-ffi) - call into Rust via C FFI.
  * Fast, simple, no SWAG/headers to compile
* [j4rs](https://astonbitecode.github.io/blog/post/j4rs_0.6.0/) for calling Java from Rust
* [JavaCPP](https://github.com/bytedeco/javacpp)

Example:
* Use Scala/JVM for Zookeeper, distributed coordination, integration layers
* Use Rust for high-performance, memory-heavy portion

---

# Taking Safety back to Scala from Rust

```scala
  final case class U8(addr: Long) extends AnyVal {
    // Simple pointer math, by # of U8 elements (bytes)
    final def add(offset: Int): U8 = U8(addr + offset)
    //scalastyle:off method.name
    final def +(offset: Int): U8 = U8(addr + offset)

    final def getU8: Int = UnsafeUtils.getByte(addr) & 0x00ff

    final def asU16: U16 = U16(addr)
    final def asI32: I32 = I32(addr)
    final def asMut: MutU8 = MutU8(addr)
  }

  final case class MutU8(addr: Long) extends AnyVal {
    final def set(num: Int): Unit = UnsafeUtils.setByte(addr, num.toByte)
  }
```

For offheap data management: explicit Ptr type >> using Longs or type aliases; separate Mutable type; explicit conversions to different widths

---

# Thank You Very Much

More links:

* https://github.com/velvia/links/blob/master/rust.md

---

class: center, middle

# Extra Slides

---

# Look, you can still do FP

---

# Other neat type-level stuff

Typestate pattern in Rust: http://cliffle.com/blog/rust-typestate/

* Allow operations only for certain types/states
* Static nature of Rust traits lets you define methods only when a trait has parameter of certain type

```rust
/// Operations that are valid only in Start state.
impl HttpResponse<Start> {
    fn status_line(self, code: u8, message: &str)
        -> HttpResponse<Headers>
    {
        // ...
    }
}

/// Operations that are valid only in Headers state.
impl HttpResponse<Headers> {
    fn header(&mut self, key: &str, value: &str) {
        // ...
    }

    fn body(self, contents: &str) {
        // ...
    }
}
```

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script src="../mermaid.min.js"></script>
    <link rel="stylesheet" href="../mermaid.css">
    <script>mermaid.initialize({startOnLoad:true});</script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>